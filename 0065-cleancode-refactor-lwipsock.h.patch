From 09b9d85b915c5a9d52c624f9a155d20eab564e82 Mon Sep 17 00:00:00 2001
From: Lemmy Huang <huangliming5@huawei.com>
Date: Fri, 19 May 2023 10:52:49 +0800
Subject: [PATCH 3/3] cleancode: refactor lwipsock.h

Signed-off-by: Lemmy Huang <huangliming5@huawei.com>
---
 src/api/api_msg.c                    |   5 +-
 src/api/gazelle_dir.mk               |   2 +-
 src/api/gazelle_posix_api.c          |  10 --
 src/api/gazelle_sock.c               | 134 ++++++++++++++++
 src/api/sockets.c                    | 226 ++++++---------------------
 src/core/pbuf.c                      |   1 +
 src/core/tcp.c                       |   2 +-
 src/include/gazelle_posix_api.h      |   2 -
 src/include/lwip/api.h               |  35 -----
 src/include/lwip/priv/sockets_priv.h |   2 +-
 src/include/lwipsock.h               | 128 +++++++--------
 11 files changed, 250 insertions(+), 297 deletions(-)
 create mode 100644 src/api/gazelle_sock.c

diff --git a/src/api/api_msg.c b/src/api/api_msg.c
index 18f33ef..b4333f5 100644
--- a/src/api/api_msg.c
+++ b/src/api/api_msg.c
@@ -58,6 +58,7 @@
 #include "lwip/sockets.h"
 #include "lwipsock.h"
 #include "gazelle_posix_api.h"
+extern void gazelle_connected_callback(struct netconn *conn);
 #endif
 
 #include <string.h>
@@ -614,10 +615,6 @@ accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
     API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
   }
 
-#if GAZELLE_ENABLE
-  LWIP_DEBUGF(API_MSG_DEBUG, ("libos incoming connection established\n"));
-  SET_CONN_TYPE_LIBOS(newconn);
-#endif
   return ERR_OK;
 }
 #endif /* LWIP_TCP */
diff --git a/src/api/gazelle_dir.mk b/src/api/gazelle_dir.mk
index d51ad43..38daa53 100644
--- a/src/api/gazelle_dir.mk
+++ b/src/api/gazelle_dir.mk
@@ -1,3 +1,3 @@
-SRC = api_lib.c api_msg.c err.c netbuf.c netdb.c netifapi.c sockets.c tcpip.c sys_arch.c gazelle_posix_api.c
+SRC = api_lib.c api_msg.c err.c netbuf.c netdb.c netifapi.c sockets.c tcpip.c sys_arch.c gazelle_posix_api.c gazelle_sock.c
 
 $(eval $(call register_dir, api, $(SRC)))
diff --git a/src/api/gazelle_posix_api.c b/src/api/gazelle_posix_api.c
index 8bd4ce0..219769a 100644
--- a/src/api/gazelle_posix_api.c
+++ b/src/api/gazelle_posix_api.c
@@ -51,17 +51,11 @@ static int chld_is_epfd(int fd)
     return 0;
 }
 
-static struct lwip_sock *chld_get_socket(int fd)
-{
-    return NULL;
-}
-
 void posix_api_fork(void)
 {
     /* lstack helper api */
     posix_api->ues_posix = 1;
     posix_api->is_epfd = chld_is_epfd;
-    posix_api->get_socket = chld_get_socket;
 }
 
 
@@ -114,10 +108,6 @@ int posix_api_init(void)
     CHECK_DLSYM_RET_RETURN(posix_api->poll_fn = dlsym(handle, "poll"));
     CHECK_DLSYM_RET_RETURN(posix_api->ioctl_fn = dlsym(handle, "ioctl"));
 
-    /* lstack helper api */
-    posix_api->get_socket = get_socket;
-    posix_api->epoll_close_fn = lstack_epoll_close;
-
     /* support fork */
     posix_api->ues_posix = 1;
     return ERR_OK;
diff --git a/src/api/gazelle_sock.c b/src/api/gazelle_sock.c
new file mode 100644
index 0000000..1164485
--- /dev/null
+++ b/src/api/gazelle_sock.c
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Huawei Technologies
+ *
+ */
+
+#include <sys/socket.h>
+
+#include "lwipsock.h"
+#include "gazelle_posix_api.h"
+#include "lwip/tcp.h"
+
+extern struct lwip_sock *sockets[MEMP_NUM_NETCONN]; // NUM_SOCKETS
+
+extern void gazelle_init_sock(int32_t fd);
+extern void gazelle_clean_sock(int32_t fd);
+
+static int socket_sys_type(enum netconn_type type)
+{
+  int sys_type;
+  switch (NETCONNTYPE_GROUP(type)) {
+    case NETCONN_RAW:
+      sys_type = SOCK_RAW;
+      break;
+    case NETCONN_UDPLITE:
+    case NETCONN_UDP:
+      sys_type = SOCK_DGRAM;
+      break;
+    case NETCONN_TCP:
+      sys_type = SOCK_STREAM;
+      break;
+    default:
+      sys_type = -1;
+      break;
+  }
+  return sys_type;
+}
+
+static int socket_new_sysfd(struct netconn *newconn, int accepted, int flags)
+{
+  int domain = AF_INET;
+  int protocol = 0;
+  /*add SOCK_CLOEXEC OR SOCK_NONBLOCK OR NONE*/
+  int type = socket_sys_type(newconn->type) | flags;
+
+  return posix_api->socket_fn(domain, type, protocol);
+}
+
+static struct lwip_sock *socket_new_sock(int fd)
+{
+  struct lwip_sock *sock;
+
+  sock = lwip_get_socket_nouse(fd);
+  gazelle_init_sock(fd);
+  return sock;
+}
+
+/* reference tag: alloc_socket() */
+int gazelle_alloc_socket(struct netconn *newconn, int accepted, int flags)
+{
+  int fd;
+  struct lwip_sock *sock;
+
+  fd = socket_new_sysfd(newconn, accepted, flags);
+  if (fd < 0) {
+    return -1;
+  }
+  sock = socket_new_sock(fd);
+  if (sock == NULL) {
+    return -1;
+  }
+  netconn_set_nonblocking(newconn, flags & SOCK_NONBLOCK);
+
+  sock->conn       = newconn;
+  sock->lastdata.pbuf = NULL;
+#if LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL
+  LWIP_ASSERT("sock->select_waiting == 0", sock->select_waiting == 0);
+  sock->rcvevent   = 0;
+  /* TCP sendbuf is empty, but the socket is not yet writable until connected
+   * (unless it has been created by accept()). */
+  sock->sendevent  = (NETCONNTYPE_GROUP(newconn->type) == NETCONN_TCP ? (accepted != 0) : 1);
+  sock->errevent   = 0;
+#endif /* LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL */
+
+  return fd;
+}
+
+/* reference tag: free_socket() */
+void gazelle_free_socket(struct lwip_sock *sock, int fd)
+{
+  /* remove sock from same_node_recv_lit */
+  list_del_node_null(&sock->recv_list);
+  gazelle_clean_sock(fd);
+  posix_api->close_fn(fd);
+}
+
+void lwip_exit(void)
+{
+  /*
+   * LwIP has the following two parts of memory application, but
+   * it is unnecessary to release all memory in sequentially,
+   * which increases complexity. Therefore, we rely on the process
+   * reclamation mechanism of the system to release memory.
+   * 1. a sockets table of the process.
+   * 2. a batch of hugepage memory of each thread.
+   */
+  return;
+}
diff --git a/src/api/sockets.c b/src/api/sockets.c
index f402db8..8a7b9b8 100644
--- a/src/api/sockets.c
+++ b/src/api/sockets.c
@@ -54,7 +54,6 @@
 #include "lwip/netif.h"
 #include "lwip/priv/tcpip_priv.h"
 #include "lwip/mld6.h"
-#include "lwip/api.h"
 #if LWIP_CHECKSUM_ON_COPY
 #include "lwip/inet_chksum.h"
 #endif
@@ -64,7 +63,6 @@
 #endif
 
 #if GAZELLE_ENABLE
-#include <stdarg.h>
 #include "lwipsock.h"
 #include "gazelle_posix_api.h"
 #endif
@@ -93,15 +91,16 @@
 #define API_SELECT_CB_VAR_FREE(name)              API_VAR_FREE(MEMP_SELECT_CB, name)
 
 #if LWIP_IPV4
-#if GAZELLE_ENABLE
+#if !GAZELLE_ENABLE
+/* Consistent with kernel definitions */
 #define IP4ADDR_PORT_TO_SOCKADDR(sin, ipaddr, port) do { \
+      (sin)->sin_len = sizeof(struct sockaddr_in); \
       (sin)->sin_family = AF_INET; \
       (sin)->sin_port = lwip_htons((port)); \
       inet_addr_from_ip4addr(&(sin)->sin_addr, ipaddr); \
       memset((sin)->sin_zero, 0, SIN_ZERO_LEN); }while(0)
-#else
+#else /* GAZELLE_ENABLE */
 #define IP4ADDR_PORT_TO_SOCKADDR(sin, ipaddr, port) do { \
-      (sin)->sin_len = sizeof(struct sockaddr_in); \
       (sin)->sin_family = AF_INET; \
       (sin)->sin_port = lwip_htons((port)); \
       inet_addr_from_ip4addr(&(sin)->sin_addr, ipaddr); \
@@ -272,11 +271,10 @@ static void lwip_socket_drop_registered_mld6_memberships(int s);
 #endif /* LWIP_IPV6_MLD */
 
 /** The global array of available sockets */
-#if GAZELLE_ENABLE
-uint32_t sockets_num;
-struct lwip_sock *sockets;
-#else
+#if !GAZELLE_ENABLE
 static struct lwip_sock sockets[NUM_SOCKETS];
+#else /* GAZELLE_ENABLE */
+struct lwip_sock sockets[NUM_SOCKETS];
 #endif /* GAZELLE_ENABLE */
 
 #if LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL
@@ -305,7 +303,7 @@ static struct lwip_select_cb *select_cb_list;
 
 /* Forward declaration of some functions */
 #if LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL
-void event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len);
+static void event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len);
 #define DEFAULT_SOCKET_EVENTCB event_callback
 static void select_check_waiters(int s, int has_recvevent, int has_sendevent, int has_errevent);
 #else
@@ -431,19 +429,20 @@ static struct lwip_sock *
 tryget_socket_unconn_nouse(int fd)
 {
   int s = fd - LWIP_SOCKET_OFFSET;
-
-#if GAZELLE_ENABLE
-  if ((s < 0) || (s >= sockets_num))
-#else
-  if ((s < 0) || (s >= NUM_SOCKETS))
-#endif /* GAZELLE_ENABLE */
-  {
+  if ((s < 0) || (s >= NUM_SOCKETS)) {
     LWIP_DEBUGF(SOCKETS_DEBUG, ("tryget_socket_unconn(%d): invalid\n", fd));
     return NULL;
   }
   return &sockets[s];
 }
 
+#if GAZELLE_ENABLE
+struct lwip_sock *lwip_get_socket_nouse(int fd)
+{
+  return tryget_socket_unconn_nouse(fd);
+}
+#endif /* GAZELLE_ENABLE */
+
 struct lwip_sock *
 lwip_socket_dbg_get_socket(int fd)
 {
@@ -501,13 +500,8 @@ tryget_socket(int fd)
  * @param fd externally used socket index
  * @return struct lwip_sock for the socket or NULL if not found
  */
-#if GAZELLE_ENABLE
-struct lwip_sock *
-get_socket(int fd)
-#else
 static struct lwip_sock *
 get_socket(int fd)
-#endif /* GAZELLE_ENABLE */
 {
   struct lwip_sock *sock = tryget_socket(fd);
   if (!sock) {
@@ -520,108 +514,22 @@ get_socket(int fd)
   return sock;
 }
 
-#if GAZELLE_ENABLE
-/**
- * Map a externally used socket index to the internal socket representation.
- *
- * @param s externally used socket index
- * @return struct lwip_sock for the socket or NULL if not found without
- * checking.
- */
-struct lwip_sock *
-get_socket_by_fd(int fd)
-{
-  if ((fd < LWIP_SOCKET_OFFSET) || (fd >= sockets_num + LWIP_SOCKET_OFFSET)) {
-    return NULL;
-  }
-  return &sockets[fd - LWIP_SOCKET_OFFSET];
-}
-#endif /* GAZELLE_ENABLE */
-
 /**
  * Allocate a new socket for a given netconn.
  *
  * @param newconn the netconn for which to allocate a socket
  * @param accepted 1 if socket has been created by accept(),
  *                 0 if socket has been created by socket()
- * @param flags  only support SOCK_CLOEXEC and SOCK_NONBLOCK
  * @return the index of the new socket; -1 on error
  */
+#if !GAZELLE_ENABLE
 static int
-alloc_socket(struct netconn *newconn, int accepted, int flags)
+alloc_socket(struct netconn *newconn, int accepted)
 {
   int i;
   SYS_ARCH_DECL_PROTECT(lev);
   LWIP_UNUSED_ARG(accepted);
 
-#if GAZELLE_ENABLE
-  int type, protocol = 0, domain = AF_INET;
-  switch (NETCONNTYPE_GROUP(newconn->type)) {
-    case NETCONN_RAW:
-      type = SOCK_RAW;
-      break;
-    case NETCONN_UDPLITE:
-    case NETCONN_UDP:
-      type = SOCK_DGRAM;
-      break;
-    case NETCONN_TCP:
-      type = SOCK_STREAM;
-      break;
-    default:
-      type = -1;
-      break;
-  }
-
-  /*add CLOEXEC OR NONBLOCK OR NONE*/
-  type |= flags;
-
-  SYS_ARCH_PROTECT(lev);
-  i = posix_api->socket_fn(domain, type, protocol);
-  if (i == -1) {
-    goto err;
-  }
-
-  if ((flags & O_NONBLOCK) != 0){
-    netconn_set_nonblocking(newconn, flags & O_NONBLOCK);
-  }
-
-  if ((i < LWIP_SOCKET_OFFSET) || (i >= sockets_num + LWIP_SOCKET_OFFSET)) {
-    goto err;
-  }
-
-  if (!sockets[i].conn && (sockets[i].select_waiting == 0)) {
-    /*initialize state as NETCONN_HOST | NETCONN_LIBOS,
-     *if connection accepted and alloc_socket called, it can be only NETCONN_LIBOS*/
-    if (accepted)
-      SET_CONN_TYPE_LIBOS(newconn);
-    else
-      SET_CONN_TYPE_LIBOS_OR_HOST(newconn);
-    sockets[i].conn       = newconn;
-    /* The socket is not yet known to anyone, so no need to protect
-       after having marked it as used. */
-    SYS_ARCH_UNPROTECT(lev);
-    sockets[i].lastdata.pbuf = NULL;
-    sockets[i].rcvevent   = 0;
-    /* TCP sendbuf is empty, but the socket is not yet writable until connected
-     * (unless it has been created by accept()). */
-    sockets[i].sendevent  = (NETCONNTYPE_GROUP(newconn->type) == NETCONN_TCP ? (accepted != 0) : 1);
-    sockets[i].errevent   = 0;
-    sockets[i].same_node_rx_ring = NULL;
-    sockets[i].same_node_rx_ring_mz = NULL;
-    sockets[i].same_node_tx_ring = NULL;
-    sockets[i].same_node_tx_ring_mz = NULL;
-    return i + LWIP_SOCKET_OFFSET;
-  } else {
-    lwip_close(i);
-    gazelle_clean_sock(i);
-  }
-
-err:
-  posix_api->close_fn(i);
-  SYS_ARCH_UNPROTECT(lev);
-  return -1;
-#else /* GAZELLE_ENABLE */
-
   /* allocate a new socket identifier */
   for (i = 0; i < NUM_SOCKETS; ++i) {
     /* Protect socket array */
@@ -653,9 +561,8 @@ err:
     SYS_ARCH_UNPROTECT(lev);
   }
   return -1;
-
-#endif /* GAZELLE_ENABLE */
 }
+#endif /* GAZELLE_ENABLE */
 
 /** Free a socket (under lock)
  *
@@ -721,11 +628,6 @@ free_socket(struct lwip_sock *sock, int is_tcp)
   /* Protect socket array */
   SYS_ARCH_PROTECT(lev);
 
-#if GAZELLE_ENABLE
-  /* remove sock from same_node_recv_lit */
-  list_del_node_null(&sock->recv_list);
-#endif
-
   freed = free_socket_locked(sock, is_tcp, &conn, &lastdata);
   SYS_ARCH_UNPROTECT(lev);
   /* don't use 'sock' after this line, as another task might have allocated it */
@@ -754,7 +656,6 @@ lwip_accept4(int s, struct sockaddr *addr, socklen_t *addrlen, int flags)
   SYS_ARCH_DECL_PROTECT(lev);
 
   LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
-
   sock = get_socket(s);
   if (!sock) {
     return -1;
@@ -776,21 +677,19 @@ lwip_accept4(int s, struct sockaddr *addr, socklen_t *addrlen, int flags)
   }
   LWIP_ASSERT("newconn != NULL", newconn != NULL);
 
-  newsock = alloc_socket(newconn, 1, flags);
+#if !GAZELLE_ENABLE
+  newsock = alloc_socket(newconn, 1);
+#else
+  newsock = gazelle_alloc_socket(newconn, 1, flags);
+#endif
   if (newsock == -1) {
     netconn_delete(newconn);
     sock_set_errno(sock, ENFILE);
     done_socket(sock);
     return -1;
   }
-#if GAZELLE_ENABLE
-  LWIP_ASSERT("invalid socket index", (newsock >= LWIP_SOCKET_OFFSET) && (newsock < sockets_num + LWIP_SOCKET_OFFSET));
-  gazelle_init_sock(newsock);
-#else
   LWIP_ASSERT("invalid socket index", (newsock >= LWIP_SOCKET_OFFSET) && (newsock < NUM_SOCKETS + LWIP_SOCKET_OFFSET));
-#endif /* GAZELLE_ENABLE */
   nsock = &sockets[newsock - LWIP_SOCKET_OFFSET];
-#if GAZELLE_ENABLE
   struct tcp_pcb *pcb = newconn->pcb.tcp;
   if (pcb->client_rx_ring != NULL && pcb->client_tx_ring != NULL) {
     if (find_same_node_memzone(pcb, nsock) != 0) {
@@ -801,7 +700,6 @@ lwip_accept4(int s, struct sockaddr *addr, socklen_t *addrlen, int flags)
       return -1;
     }
   }
-#endif
 
   /* See event_callback: If data comes in right away after an accept, even
    * though the server task might not have created a new socket yet.
@@ -832,6 +730,9 @@ lwip_accept4(int s, struct sockaddr *addr, socklen_t *addrlen, int flags)
     if (err != ERR_OK) {
       LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
       free_socket(nsock, 1);
+#if GAZELLE_ENABLE
+      gazelle_free_socket(nsock, newsock);
+#endif /* GAZELLE_ENABLE */
       sock_set_errno(sock, err_to_errno(err));
       done_socket(sock);
       return -1;
@@ -843,7 +744,7 @@ lwip_accept4(int s, struct sockaddr *addr, socklen_t *addrlen, int flags)
       *addrlen = tempaddr.sa.sa_len;
     }
 #else
-        *addrlen = LWIP_MIN(*addrlen, sizeof(tempaddr));
+    *addrlen = LWIP_MIN(*addrlen, sizeof(tempaddr));
 #endif /* GAZELLE_ENABLE */
     MEMCPY(addr, &tempaddr, *addrlen);
 
@@ -854,6 +755,9 @@ lwip_accept4(int s, struct sockaddr *addr, socklen_t *addrlen, int flags)
     LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d", s, newsock));
   }
 
+#if GAZELLE_ENABLE
+  POSIX_SET_TYPE(nsock, POSIX_LWIP);
+#endif /* GAZELLE_ENABLE */
   sock_set_errno(sock, 0);
   done_socket(sock);
   done_socket(nsock);
@@ -957,6 +861,9 @@ lwip_close(int s)
   }
 
   free_socket(sock, is_tcp);
+#if GAZELLE_ENABLE
+  gazelle_free_socket(sock, s);
+#endif /* GAZELLE_ENABLE */
   set_errno(0);
   return 0;
 }
@@ -1016,8 +923,7 @@ lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
   }
 
 #if GAZELLE_ENABLE
-  LWIP_DEBUGF(SOCKETS_DEBUG, ("libos connect succeed fd=%d\n",s));
-  SET_CONN_TYPE_LIBOS(sock->conn);
+  POSIX_SET_TYPE(sock, POSIX_LWIP);
 #endif /* GAZELLE_ENABLE */
 
   LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
@@ -1166,7 +1072,6 @@ lwip_recv_tcp(struct lwip_sock *sock, void *mem, size_t len, int flags)
     apiflags |= NETCONN_DONTBLOCK | NETCONN_NOFIN;
     /* @todo: do we need to support peeking more than one pbuf? */
   } while ((recv_left > 0) && !(flags & MSG_PEEK));
-
 lwip_recv_tcp_done:
 #else /* GAZELLE_ENABLE */
   LWIP_UNUSED_ARG(recv_left);
@@ -1181,7 +1086,6 @@ lwip_recv_tcp_done:
       netconn_tcp_recvd(sock->conn, (size_t)recvd);
     }
   }
-
   sock_set_errno(sock, 0);
   return recvd;
 }
@@ -1423,7 +1327,6 @@ lwip_recvfrom(int s, void *mem, size_t len, int flags,
       done_socket(sock);
       return -1;
     }
-
     ret = (ssize_t)LWIP_MIN(LWIP_MIN(len, datagram_len), SSIZE_MAX);
     if (fromlen) {
       *fromlen = msg.msg_namelen;
@@ -1876,12 +1779,8 @@ lwip_socket(int domain, int type, int protocol)
 
   LWIP_UNUSED_ARG(domain); /* @todo: check this */
 
-  int flags = type & ~SOCK_TYPE_MASK;
-  type &= SOCK_TYPE_MASK;
-
-
   /* create a netconn */
-  switch (type) {
+  switch (type & SOCK_TYPE_MASK) {
     case SOCK_RAW:
       conn = netconn_new_with_proto_and_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_RAW),
              (u8_t)protocol, DEFAULT_SOCKET_EVENTCB);
@@ -1919,15 +1818,11 @@ lwip_socket(int domain, int type, int protocol)
     return -1;
   }
 
-  if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK)){
-    set_errno(EINVAL);
-    return -1;
-  }
-
-  if (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))
-    flags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;
-
-  i = alloc_socket(conn, 0, flags);
+#if !GAZELLE_ENABLE
+  i = alloc_socket(conn, 0);
+#else
+  i = gazelle_alloc_socket(conn, 0, type);
+#endif
 
   if (i == -1) {
     netconn_delete(conn);
@@ -2679,7 +2574,7 @@ lwip_poll_should_wake(const struct lwip_select_cb *scb, int fd, int has_recveven
  *   NETCONN_EVT_ERROR
  * This requirement will be asserted in select_check_waiters()
  */
-void
+static void
 event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
 {
   int s, check_waiters;
@@ -2977,13 +2872,12 @@ int
 lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
 {
   int err;
+  struct lwip_sock *sock = get_socket(s);
 #if !LWIP_TCPIP_CORE_LOCKING
   err_t cberr;
   LWIP_SETGETSOCKOPT_DATA_VAR_DECLARE(data);
 #endif /* !LWIP_TCPIP_CORE_LOCKING */
 
-  struct lwip_sock *sock = get_socket(s);
-
   if (!sock) {
     return -1;
   }
@@ -3428,13 +3322,12 @@ int
 lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
 {
   int err = 0;
+  struct lwip_sock *sock = get_socket(s);
 #if !LWIP_TCPIP_CORE_LOCKING
   err_t cberr;
   LWIP_SETGETSOCKOPT_DATA_VAR_DECLARE(data);
 #endif /* !LWIP_TCPIP_CORE_LOCKING */
 
-  struct lwip_sock *sock = get_socket(s);
-
   if (!sock) {
     return -1;
   }
@@ -3968,7 +3861,7 @@ lwip_setsockopt_impl(int s, int level, int optname, const void *optval, socklen_
 int
 lwip_ioctl(int s, long cmd, ...)
 {
-  struct lwip_sock *sock = posix_api->get_socket(s);
+  struct lwip_sock *sock = get_socket(s);
   u8_t val;
 
 #if LWIP_SO_RCVBUF
@@ -3986,7 +3879,7 @@ lwip_ioctl(int s, long cmd, ...)
   if (!sock) {
     return posix_api->ioctl_fn(s, cmd, argp);
   }
-  if (CONN_TYPE_HAS_HOST(sock->conn)) {
+  if (POSIX_HAS_TYPE(sock, POSIX_KERNEL)) {
     if ((ret = posix_api->ioctl_fn(s, cmd, argp)) == -1)
       return ret;
   }
@@ -4415,31 +4308,4 @@ lwip_socket_drop_registered_mld6_memberships(int s)
 }
 #endif /* LWIP_IPV6_MLD */
 
-#if GAZELLE_ENABLE
-void lwip_sock_init(void)
-{
-  if (sockets_num == 0) {
-    sockets_num = NUM_SOCKETS;
-    sockets = calloc(sockets_num, sizeof(struct lwip_sock));
-    LWIP_ASSERT("sockets != NULL", sockets != NULL);
-    memset(sockets, 0, sockets_num * sizeof(struct lwip_sock));
-  }
-  return;
-}
-
-void lwip_exit(void)
-{
-  /*
-   * LwIP has the following two parts of memory application, but
-   * it is unnecessary to release all memory in sequentially,
-   * which increases complexity. Therefore, we rely on the process
-   * reclamation mechanism of the system to release memory.
-   * 1. a sockets table of the process.
-   * 2. a batch of hugepage memory of each thread.
-   */
-  return;
-}
-
-#endif /* GAZELLE_ENABLE */
-
 #endif /* LWIP_SOCKET */
diff --git a/src/core/pbuf.c b/src/core/pbuf.c
index aae6008..16615c6 100644
--- a/src/core/pbuf.c
+++ b/src/core/pbuf.c
@@ -86,6 +86,7 @@
 #endif
 #if GAZELLE_ENABLE
 #include <rte_prefetch.h>
+extern void gazelle_free_pbuf(struct pbuf *pbuf);
 #endif
 
 #include <string.h>
diff --git a/src/core/tcp.c b/src/core/tcp.c
index 3abf63b..6a9c9fe 100644
--- a/src/core/tcp.c
+++ b/src/core/tcp.c
@@ -258,7 +258,7 @@ tcp_free(struct tcp_pcb *pcb)
     rte_ring_free(pcb->client_rx_ring);
     rte_ring_free(pcb->client_tx_ring);
     netconn = (struct netconn *)pcb->callback_arg;
-    sock = get_socket(netconn->socket);
+    sock = lwip_get_socket_nouse(netconn->socket);
     rte_memzone_free(sock->same_node_rx_ring->mz);
     rte_memzone_free(sock->same_node_rx_ring_mz);
     rte_memzone_free(sock->same_node_tx_ring->mz);
diff --git a/src/include/gazelle_posix_api.h b/src/include/gazelle_posix_api.h
index 0bed1de..6df414b 100644
--- a/src/include/gazelle_posix_api.h
+++ b/src/include/gazelle_posix_api.h
@@ -71,10 +71,8 @@ typedef struct {
     int (*epoll_create1_fn)(int size);
     int (*epoll_ctl_fn)(int epfd, int op, int fd, struct epoll_event *event);
     int (*epoll_wait_fn)(int epfd, struct epoll_event *events, int maxevents, int timeout);
-    int (*epoll_close_fn)(int epfd);
     int (*eventfd_fn)(unsigned int initval, int flags);
     int (*is_epfd)(int fd);
-    struct lwip_sock* (*get_socket)(int fd);
     int (*sigaction_fn)(int signum, const struct sigaction *act, struct sigaction *oldact);
     int (*poll_fn)(struct pollfd *fds, nfds_t nfds, int timeout);
     int (*ioctl_fn)(int fd, int cmd, ...);
diff --git a/src/include/lwip/api.h b/src/include/lwip/api.h
index 197faef..d3c4f02 100644
--- a/src/include/lwip/api.h
+++ b/src/include/lwip/api.h
@@ -140,43 +140,8 @@ enum netconn_type {
   /** Raw connection IPv6 (dual-stack by default, unless you call @ref netconn_set_ipv6only) */
   , NETCONN_RAW_IPV6    = NETCONN_RAW | NETCONN_TYPE_IPV6 /* 0x48 */
 #endif /* LWIP_IPV6 */
-
-#if GAZELLE_ENABLE
-  /*here must bigger than 0xff, because (type & 0xff) is for lwip inner use*/
-  , NETCONN_LIBOS = 0x100
-  , NETCONN_HOST = 0x200
-  , NETCONN_INPRG = 0x400
-  , NETCONN_STACK = NETCONN_LIBOS | NETCONN_HOST | NETCONN_INPRG
-#endif /* GAZELLE_ENABLE */
 };
 
-#ifdef GAZELLE_ENABLE
-#define SET_CONN_TYPE_LIBOS_OR_HOST(conn) do { \
-  conn->type &= ~(NETCONN_STACK); \
-  conn->type |= (NETCONN_LIBOS | NETCONN_HOST); } while (0)
-#define SET_CONN_TYPE_LIBOS(conn) do { \
-  conn->type &= ~(NETCONN_STACK); \
-  conn->type |= NETCONN_LIBOS; } while (0)
-#define SET_CONN_TYPE_HOST(conn) do { \
-  conn->type &= ~(NETCONN_STACK); \
-  conn->type |= NETCONN_HOST; } while (0)
-#define ADD_CONN_TYPE_INPRG(conn) do { \
-  conn->type |= NETCONN_INPRG; } while(0)
-#define CONN_TYPE_HAS_LIBOS_AND_HOST(conn) ((conn->type & (NETCONN_LIBOS | NETCONN_HOST)) == (NETCONN_LIBOS | NETCONN_HOST))
-#define CONN_TYPE_HAS_LIBOS(conn) (conn->type & NETCONN_LIBOS)
-#define CONN_TYPE_HAS_HOST(conn) (conn->type & NETCONN_HOST)
-#define CONN_TYPE_HAS_INPRG(conn) (!!(conn->type & NETCONN_INPRG))
-#define CONN_TYPE_IS_LIBOS(conn)  (!!(NETCONN_LIBOS == (conn->type & NETCONN_STACK)))
-#define CONN_TYPE_IS_HOST(conn)   (!!(NETCONN_HOST == (conn->type & NETCONN_STACK)))
-#else
-#define SET_CONN_TYPE_LIBOS_OR_HOST(conn) do {} while (0)
-#define SET_CONN_TYPE_LIBOS(conn) do {} while (0)
-#define SET_CONN_TYPE_HOST(conn) do {} while (0)
-#define CONN_TYPE_HAS_LIBOS_AND_HOST(conn) (0)
-#define CONN_TYPE_HAS_LIBOS(conn) (0)
-#define CONN_TYPE_HAS_HOST(conn) (0)
-#endif /* GAZELLE_ENABLE */
-
 /** Current state of the netconn. Non-TCP netconns are always
  * in state NETCONN_NONE! */
 enum netconn_state {
diff --git a/src/include/lwip/priv/sockets_priv.h b/src/include/lwip/priv/sockets_priv.h
index 7268a17..4b85935 100644
--- a/src/include/lwip/priv/sockets_priv.h
+++ b/src/include/lwip/priv/sockets_priv.h
@@ -45,7 +45,7 @@
 #include "lwip/sockets.h"
 #include "lwip/sys.h"
 
-/* move some definitions to the lwipsock.h for libnet to use, and
+/* move some definitions to the lwipsock.h for `gazelle` to use, and
  * at the same time avoid conflict between lwip/sockets.h and sys/socket.h
  */
 #include "lwipsock.h"
diff --git a/src/include/lwipsock.h b/src/include/lwipsock.h
index 1814f76..32ec721 100644
--- a/src/include/lwipsock.h
+++ b/src/include/lwipsock.h
@@ -33,13 +33,73 @@
 #ifndef _LWIPSOCK_H_
 #define _LWIPSOCK_H_
 
-#include <semaphore.h>
 #include "lwip/opt.h"
 #include "lwip/api.h"
 
+#if GAZELLE_ENABLE
+#include <semaphore.h>
+#include <rte_common.h>
+#include <rte_memzone.h>
 #include "gazelle_event.h"
 
-/* move some definitions to the lwipsock.h for libnet to use, and
+#define set_errno(err) do { errno = (err); } while(0)
+
+enum posix_type {
+  POSIX_KERNEL  = 0x100,
+  POSIX_LWIP    = 0x200,
+  POSIX_EPOLL   = 0x400,
+  POSIX_ALL     = POSIX_KERNEL | POSIX_LWIP | POSIX_EPOLL,
+  POSIX_LWIP_OR_KERNEL = POSIX_LWIP | POSIX_KERNEL,
+};
+
+#define POSIX_SET_TYPE(sock, posix_type)  do { \
+  (sock)->type &= ~(POSIX_ALL);                \
+  (sock)->type |= (posix_type);           } while (0)
+
+#define POSIX_HAS_TYPE(sock, posix_type) \
+  ((sock)->type & (posix_type))
+
+#define POSIX_IS_TYPE(sock, posix_type) \
+  (((sock)->type & POSIX_ALL) == (posix_type))
+
+struct lwip_sock *lwip_get_socket_nouse(int fd);
+int gazelle_alloc_socket(struct netconn *newconn, int accepted, int flags);
+void gazelle_free_socket(struct lwip_sock *sock, int fd);
+void lwip_exit(void);
+
+struct protocol_stack;
+struct wakeup_poll;
+
+extern void add_recv_list(int32_t fd);
+extern ssize_t read_lwip_data(struct lwip_sock *sock, int32_t flags, u8_t apiflags);
+extern struct pbuf *write_lwip_data(struct lwip_sock *sock, uint16_t remain_size, uint8_t *apiflags);
+extern void write_lwip_over(struct lwip_sock *sock);
+extern void lstack_calculate_aggregate(int type, uint32_t len);
+
+extern void netif_poll(struct netif *netif);
+extern err_t netif_loop_output(struct netif *netif, struct pbuf *p);
+
+
+// 8M
+#define SAME_NODE_RING_LEN (unsigned long long)(8388608)
+#define SAME_NODE_RING_MASK (unsigned long long)(8388608 - 1)
+#define RING_NAME_LEN 32
+struct same_node_ring {
+    const struct rte_memzone *mz;
+    unsigned long long sndbegin;
+    unsigned long long sndend;
+};
+
+extern err_t find_same_node_memzone(struct tcp_pcb *pcb, struct lwip_sock *nsock);
+extern err_t same_node_memzone_create(const struct rte_memzone **zone, int size, int port, char *name, char *);
+extern err_t same_node_ring_create(struct rte_ring **ring, int size, int port, char *name, char *rx);
+extern err_t create_same_node_ring(struct tcp_pcb *pcb);
+extern err_t find_same_node_ring(struct tcp_pcb *pcb);
+
+#endif /* GAZELLE_ENABLE */
+
+
+/* move some definitions to the lwipsock.h for `gazelle` to use, and
  * at the same time avoid conflict between lwip/sockets.h and sys/socket.h
  */
 
@@ -60,24 +120,6 @@ union lwip_sock_lastdata {
   struct pbuf *pbuf;
 };
 
-#if GAZELLE_ENABLE
-struct protocol_stack;
-struct wakeup_poll;
-struct rte_ring;
-#include <rte_common.h>
-#include <rte_memzone.h>
-
-// 8M
-#define SAME_NODE_RING_LEN (unsigned long long)(8388608)
-#define SAME_NODE_RING_MASK (unsigned long long)(8388608 - 1)
-#define RING_NAME_LEN 32
-struct same_node_ring {
-    const struct rte_memzone *mz;
-    unsigned long long sndbegin;
-    unsigned long long sndend;
-};
-#endif
-
 /** Contains all internal pointers and states used for a socket */
 struct lwip_sock {
   /** sockets currently are built on netconns, each socket has one netconn */
@@ -126,10 +168,11 @@ struct lwip_sock {
 
   char pad3 __rte_cache_aligned;
   /* nerver change */
-  struct wakeup_poll *wakeup;
-  epoll_data_t ep_data;
+  enum posix_type type;
   struct lwip_sock *listen_next; /* listenfd list */
   struct protocol_stack *stack;
+  struct wakeup_poll *wakeup;
+  epoll_data_t ep_data;
   struct rte_ring *recv_ring;
   struct rte_ring *send_ring;
 
@@ -142,49 +185,8 @@ struct lwip_sock {
 #endif
 };
 
-#if GAZELLE_ENABLE
-static inline unsigned same_node_ring_count(struct lwip_sock *sock)
-{
-  const unsigned long long cur_begin = __atomic_load_n(&sock->same_node_rx_ring->sndbegin, __ATOMIC_RELAXED);
-  const unsigned long long cur_end = __atomic_load_n(&sock->same_node_rx_ring->sndend, __ATOMIC_RELAXED);
-
-  return cur_end - cur_begin;
-}
-#endif
-
 #ifndef set_errno
 #define set_errno(err) do { if (err) { errno = (err); } } while(0)
 #endif
 
-
-/* --------------------------------------------------
- * --------------- LIBNET references ----------------
- * --------------------------------------------------
- */
-#if GAZELLE_ENABLE
-extern uint32_t sockets_num;
-extern struct lwip_sock *sockets;
-extern void gazelle_connected_callback(struct netconn *conn);
-extern void add_recv_list(int32_t fd);
-extern ssize_t read_lwip_data(struct lwip_sock *sock, int32_t flags, u8_t apiflags);
-extern struct pbuf *write_lwip_data(struct lwip_sock *sock, uint16_t remain_size, uint8_t *apiflags);
-extern void gazelle_init_sock(int32_t fd);
-extern void gazelle_clean_sock(int32_t fd);
-extern void write_lwip_over(struct lwip_sock *sock);
-extern void netif_poll(struct netif *netif);
-extern err_t netif_loop_output(struct netif *netif, struct pbuf *p);
-extern err_t find_same_node_memzone(struct tcp_pcb *pcb, struct lwip_sock *nsock);
-extern err_t same_node_memzone_create(const struct rte_memzone **zone, int size, int port, char *name, char *);
-extern err_t same_node_ring_create(struct rte_ring **ring, int size, int port, char *name, char *rx);
-extern err_t create_same_node_ring(struct tcp_pcb *pcb);
-extern err_t find_same_node_ring(struct tcp_pcb *pcb);
-extern void gazelle_free_pbuf(struct pbuf *pbuf);
-extern void lstack_calculate_aggregate(int type, uint32_t len);
-#endif /* GAZELLE_ENABLE */
-
-struct lwip_sock *get_socket(int s);
-struct lwip_sock *get_socket_by_fd(int s);
-void lwip_sock_init(void);
-void lwip_exit(void);
-
 #endif /* _LWIPSOCK_H_ */
-- 
2.22.0.windows.1

